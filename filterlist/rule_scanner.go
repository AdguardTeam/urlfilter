package filterlist

import (
	"bufio"
	"io"

	"github.com/AdguardTeam/urlfilter/rules"
)

// RuleScanner implements an interface for reading filtering rules.
type RuleScanner struct {
	listID         int  // filter list ID
	ignoreCosmetic bool // true if we should ignore cosmetic rules

	reader           *bufio.Reader
	currentPos       int        // current position in the reader
	currentRule      rules.Rule // current rule
	currentRuleIndex int        // index of the beginning of the current rule
}

// NewRuleScanner returns a new RuleScanner to read from r.
// r -- source of the filtering rules
// listID -- filter list ID
// IgnoreCosmetic -- if true, cosmetic rules will be ignored
func NewRuleScanner(r io.Reader, listID int, ignoreCosmetic bool) *RuleScanner {
	return &RuleScanner{
		listID:         listID,
		ignoreCosmetic: ignoreCosmetic,
		reader:         bufio.NewReaderSize(r, readerBufferSize),
	}
}

// Scan advances the RuleScanner to the next rule, which will then be available
// through the Rule method. It returns false when the scan stops, either by
// reaching the end of the input or an error.
func (s *RuleScanner) Scan() bool {
	for {
		line, index, err := s.readNextLine()
		if err != nil {
			return false
		}

		rule, err := rules.NewRule(line, s.listID)
		if rule != nil && err == nil && !s.isIgnored(rule) {
			s.currentRule = rule
			s.currentRuleIndex = index
			return true
		}
	}
}

// Rule returns the most recent rule generated by a call to Scan, and the index of this rule's text.
func (s *RuleScanner) Rule() (rules.Rule, int) {
	return s.currentRule, s.currentRuleIndex
}

// readNextLine reads the next line and returns it and the index of the beginning of the string
func (s *RuleScanner) readNextLine() (string, int, error) {
	lineIndex := s.currentPos

	for {
		bytes, err := s.reader.ReadBytes('\n')
		if len(bytes) > 0 {
			s.currentPos += len(bytes)
			return string(bytes), lineIndex, nil
		}

		if err != nil {
			return "", lineIndex, io.EOF
		}
	}
}

// isIgnored checks if the rule should be ignored by this scanner
func (s *RuleScanner) isIgnored(f rules.Rule) bool {
	if !s.ignoreCosmetic {
		return false
	}

	if _, ok := f.(*rules.CosmeticRule); ok {
		return true
	}

	return false
}
