package urlfilter

import (
	"bufio"
	"io"
)

const readerBufferSize = 8 * 1024

// RuleScanner implements an interface for reading filtering rules.
type RuleScanner struct {
	listID         int  // filter list ID
	ignoreCosmetic bool // true if we should ignore cosmetic rules

	reader           *bufio.Reader
	currentPos       int  // current position in the reader
	currentRule      Rule // current rule
	currentRuleIndex int  // index of the beginning of the current rule
}

// NewRuleScanner returns a new RuleScanner to read from r.
// r -- source of the filtering rules
// listID -- filter list ID
// ignoreCosmetic -- if true, cosmetic rules will be ignored
func NewRuleScanner(r io.Reader, listID int, ignoreCosmetic bool) *RuleScanner {
	return &RuleScanner{
		listID:         listID,
		ignoreCosmetic: ignoreCosmetic,
		reader:         bufio.NewReaderSize(r, readerBufferSize),
	}
}

// Scan advances the RuleScanner to the next rule, which will then be available
// through the Rule method. It returns false when the scan stops, either by
// reaching the end of the input or an error.
func (s *RuleScanner) Scan() bool {
	for {
		line, index, err := s.readNextLine()
		if err != nil {
			return false
		}

		rule, err := NewRule(line, s.listID)
		if rule != nil && err == nil && !s.isIgnored(rule) {
			s.currentRule = rule
			s.currentRuleIndex = index
			return true
		}
	}
}

// Rule returns the most recent rule generated by a call to Scan, and the index of this rule's text.
func (s *RuleScanner) Rule() (Rule, int) {
	return s.currentRule, s.currentRuleIndex
}

// readNextLine reads the next line and returns it and the index of the beginning of the string
func (s *RuleScanner) readNextLine() (string, int, error) {
	line := ""
	lineIndex := s.currentPos

	for {
		bytes, isPrefix, err := s.reader.ReadLine()
		if bytes == nil || err != nil {
			return line, lineIndex, io.EOF
		}
		line += string(bytes)
		s.currentPos += len(bytes)
		if !isPrefix {
			s.currentPos++
			return line, lineIndex, nil
		}
	}
}

// isIgnored checks if the rule should be ignored by this scanner
func (s *RuleScanner) isIgnored(f Rule) bool {
	if !s.ignoreCosmetic {
		return false
	}

	if _, ok := f.(*CosmeticRule); ok {
		return true
	}

	return false
}
